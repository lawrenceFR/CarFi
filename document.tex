%!TEX program = xelatex
\documentclass[a4paper,11pt]{article}
\usepackage{hyperref}
\hypersetup{
		colorlinks = true,
    	linkcolor = blue,
    	citecolor = blue,
    	linktoc=all
}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyphenat}
\usepackage{datetime}
\usepackage{wrapfig}
\usepackage[top=3cm, bottom=3cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{url}
\usepackage{listings}
\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\color{RedOrange},
  keywordstyle=\color{blue},
  commentstyle=\color{OliveGreen},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}



\begin{document}

	\sloppy
	\fontsize{12pt}{18pt}\selectfont
	\begin{figure}[htbp]
		\begin{minipage}[b]{0.5\linewidth}
			\centering
			\includegraphics[width=\linewidth]{pictures/worldline.jpg}
		\end{minipage}
		\hspace{3cm}
		\begin{minipage}[b]{0.25\linewidth}
			\centering
			\includegraphics[width=\linewidth]{pictures/telecom.png}
		\end{minipage}
	\end{figure}

	\begin{center}
	\section*{Télécom ParisTech \\
	Promotion 2017 \\
	Sylvain DASSIER
	}
	\end{center}


	\vspace{2cm}
	\begin{center}
		\huge{\textbf{RAPPORT DE STAGE}} \\
		\vspace{1cm}
		\textbf{%
		\textcolor{blue}{Étude de l'apport du protocol MPTCP dans l'optimisation du trafic}} \\
		
	\end{center}



	\vspace{1cm}
	
		\textbf{
			\begin{tabbing}
		  		Département : ~~~~~~~~\= \textit{Département d'Informatique} \\
		 	 	Option : \> \textit{INFRES} \\
		  		Encadrants : \> \textit{M. Luigi IANNONE, M. Antoine FRESSANCOURT} \\
		  		Dates : \> \textit{18/07/2016 - 17/01/2017} \\
		 		Adresse : \> \textit{Télécom ParisTech, 23 Avenue d'Italie,} \\
		  				\> \textit{75013 Paris}
			\end{tabbing}
		}
		
	\clearpage
	
	\begin{center}
		\Huge{\textbf{Declaration d'intégrité relative au plagiat}}
	\end{center}
	\vspace{3cm}
	\emph{Je soussigné} DASSIER Sylvain \emph{certifie sur l'honneur :}\\
	\begin{enumerate}
	  	\item Que les résultats décrits dans ce rapport sont l'aboutissement de mon
	  	travail.
		\item Que je suis l'auteur de ce rapport.
		\item Que je n'ai pas utilisé des sources ou résultats tiers sans
		clairement les citer et les référencer selon les règles bibliographiques
		préconisées.
	\end{enumerate}
	\vspace{2cm}
	\includegraphics[scale=0.3]{pictures/declaration.jpg}
	
	\vspace{-1cm}
	\formatdate{17}{01}{2017}
	\hspace{5cm}
	Signature : \includegraphics[scale=0.5]{pictures/signa.jpg}
	
	\clearpage


	\section*{\Huge \textcolor{blue}{\textit{Abstract}}}
	
		\begin{description}
		
			\item \hspace{2cm} English
			
		\end{description}
		
	\section*{\Huge \textcolor{blue}{\textit{Résumé}}}
	
		\begin{description}

			\item \hspace{2cm} Français
			
		\end{description}
		
	

	\clearpage

	\setcounter{tocdepth}{3}

	\tableofcontents

	\clearpage

	
	\section{Introduction}

		\vspace{0.5cm}
		\subsection{Context}
			\begin{description}
				\item \hspace{2cm} Today, connected vehicles make use of 2G, 3G or 4G networks in order to connect to the internet while in motion. Whether it be for GPS, simple browsing or music, every consumer has his/her own needs. \\Apart from the usual connection glitches, such connectivity is rather expensive with limited bandwidth. Even though workarounds have been implemented, most of them are either inefficient or are not completely transparent. These limitations stand in the way of developement of connected vehicles. \\MultiPath TCP (MPTCP) is an effort towards enabling the simultaneous use of several IP-addresses/interfaces by a modification of TCP. It presents a regular TCP interface to applications, while in fact spreading data across several sub-flows. Benefits of this include better resource utilisation, better throughput and smoother reaction to failures. The project CarFi, aims to exploit these advantages of MPTCP. A potential add-on would be the usage of the WiFi network when available. Most urban areas are covered via Mobile Network Operator or ISP WiFi hotspots. One may envisage a scenario where the default connection is established over Wifi and when it is no longer available, the communication carries on over 3G.
			\end{description}
	
		\vspace{0.5cm}
		\subsection{Document Outline}
			\begin{description}
				\item \hspace{2cm} This document is divided into two main parts comprising different sections. The first part involves section \hyperref[sec:mptcpdebug]{2} where we describe how to set up a \textbf{\emph{debugging environment for MPTCP}}. This will help us to follow the different system calls during the establishment of a flow or a sub-flow. The next sections form the other part, dealing with the new socket API that enables us to control the MPTCP stack from user space. Section \hyperref[sec:mptcpapi]{3} gives a description of the socket API along with some details on its implementation. Section \hyperref[sec:netcat-mptcp]{4} elaborates a use case of this API, in our case a \textbf{Netcat} with \textbf{MPTCP}. Section \hyperref[sec:res]{5} summarises our results \hyperref[subsec:result]{5.1}, elucidates certain statistics \hyperref[subsec:statistics]{5.2} and emphasises on the utility \hyperref[subsec:utility]{5.3} of our work.
			\end{description}


	\clearpage

	\begin{center}
		\LARGE\textbf{PART I}
	\end{center}


	\section{Setting up a debugging environment for MPTCP : }

		\label{sec:mptcpdebug}

		In order to understand the different stages of running of the MPTCP linux kernel, we have put in place a debugging environment. This has been done with \cite[LibOS]{libos} (an MPTCP version of the library operating system of the linux kernel) and \cite[DCE]{dce} (Direct Code Execution). Everything was done on a XUbuntu 14.04 64bit virtual machine with DCE 1.8. The following illustrates how :

		\begin{enumerate}
			\sloppy
			\item \textbf{Install the dependencies :}
				
			\nohyphens{
				sudo apt-get install vim git mercurial gcc g++ python python-dev qt4-dev-tools libqt4-dev bzr cmake libc6-dev libc6-dev-i386 g++-multilib gdb valgrind gsl-bin libgsl0-dev libgsl0ldbl flex bison libfl-dev tcpdump sqlite sqlite3 libsqlite3-dev libxml2 libxml2-dev libgtk2.0-0 libgtk2.0-dev vtun lxc uncrustify doxygen graphviz imagemagick texlive texlive-extra-utils texlive-latex-extra texlive-font-utils dvipng python-sphinx dia python-pygraphviz python-kiwi python-pygoocanvas libgoocanvas-dev ipython libboost-signals-dev libboost-filesystem-dev openmpi-bin openmpi-common openmpi-doc libopenmpi-dev libncurses5-dev libncursesw5-dev unrar unrar-free p7zip-full autoconf libpcap-dev cvs libssl-dev wireshark}

			\item \textbf{Build DCE using bake :}

				\begin{enumerate}

					\item hg clone \url{http://code.nsnam.org/bake} bake
					\item export BAKE\_HOME=`pwd`/bake
					\item export PATH=\$PATH:\$BAKE\_HOME
					\item export PYTHONPATH=\$PYTHONPATH:\$BAKE\_HOME
					\item mkdir dce
					\item cd dce
					\item bake.py configure -e dce-ns3-1.8
					\item bake.py download
					\item bake.py build

				\end{enumerate}

			\item \textbf{Build the \emph{mptcp\_trunk\_libos} branch of \emph{net-next-nuse}}
				\begin{enumerate}

					\item git clone -b mptcp\_trunk\_libos \url{https://github.com/libos-nuse/net-next-nuse.git}
					\item cd net-next-nuse
					\item make menuconfig ARCH=lib
					\item make library ARCH=lib
					\item Since DCE by default, calls the library \emph{liblinux.so} (not exactly the correct one), and that the correct library is \emph{libsim-linux.so} found at \emph{\$HOME/net-next-nuse/arch/lib/tools} we rename the existing \emph{liblinux.so} to \emph{liblinux0.so} and create a symbolic link for the correct library as follows :

					\emph{ln -s \$HOME/net-next-nuse/arch/lib/tools/libsim-linux.so \$HOME/net-next-nuse/liblinux.so}.
					This will ``mislead'' DCE into loading the correct library.

				\end{enumerate}

			\item \textbf{Build \emph{iproute2} version \emph{2.6.38}}

				\begin{enumerate}
					\sloppy
					\item Download the compressed source code from \\
					\nohyphens{\emph{\url{https://kernel.googlesource.com/pub/scm/linux/kernel/git/shemminger/iproute2/+archive/fcae78992cab7bd267785b392b438306c621e583.tar.gz}}} , extract it and rename the folder to \emph{iproute2-2.6.38}. 
					\item cd iproute2-2.6.38
					\item patch -p1 -i ../ns-3-dce/utils/iproute-2.6.38-fix-01.patch
					\item \$(KERNEL\_INCLUDE) should point to the liblinux.so directory ( for me it is \$HOME/net-next-nuse ) \\
					Hence I modified the following part in the Makefile:

					\emph{
					Config: \\
	                   \hspace*{2cm}sh configure /home/lawrence/net-next-nuse \\
	                   \hspace*{2cm}\# sh configure \$(KERNEL\_MODULE) }
	                \item \raggedright{LDFLAGS=-pie make CCOPTS='-fpic -D\_GNU\_SOURCE -O0 -U\_FORTIFY\_SOURCE'}

				\end{enumerate}

			\item \textbf{Set the \emph{DCE\_PATH}} \\
				export DCE\_PATH=\$HOME/net-next-nuse:\$HOME/iproute2-2.6.38/ip

			\item \textbf{Build \emph{ns-3-dce }}
				\begin{enumerate}
				
					\item hg clone \url{http://code.nsnam.org/ns-3-dce}  -r dce-1.8
					\item cd ns-3-dce
					\item ./waf configure --with-ns3=\$HOME/dce/build --enable-kernel-stack=\$HOME/net-next-nuse/arch --prefix=\$HOME/dce/build
					\item ./waf build
				\end{enumerate}

			\item \textbf{Run \emph{dce-iperf-mptcp} with or without \emph{GDB}}
				\begin{enumerate}
					\item cd ns-3-dce
					\item Without \emph{GDB} : \emph{./waf --run dce-iperf-mptcp} \\
					\item With \emph{GDB} : \emph{./waf --run dce-iperf-mptcp --command-template=``gdb --args \%s''} \\
					Once we enter the \emph{GDB} prompt we must put a breakpoint at one of the functions in the \emph{mptcp} folder to stop there. Kindly refer to the files found at \emph{\$HOME/net-next-nuse/net/mptcp} to choose the function to define as a breakpoint. \\
					An example : \\
					Suppose we would like to stop the execution at the function \raggedright{\emph{mptcp\_set\_default\_path\_manager()}} found at \emph{\$HOME/net-next-nuse/net/mptcp/mptcp\_pm.c}, then we give the following command at the \emph{GDB} prompt : \\
					\emph{b mptcp\_set\_default\_path\_manager} \\
					\emph{GDB} will ask the following : \\
					\emph{Function ``mptcp\_set\_default\_path\_manager'' not defined.\\
					      Make breakpoint available on future shared library load? (y or [n])} \\
					Type in \textbf{\emph{y}} and press enter. We may run the program by typing \textbf{\emph{r}} and then pressing enter. \emph{GDB} will pause at the necessary breakpoint. \\
				\end{enumerate}

		\end{enumerate}






	\clearpage

	\begin{center}
		\LARGE\textbf{PART II}
	\end{center}

	\section{An Enhanced socket API for Multipath TCP : }

		\label{sec:mptcpapi}
		 In our project CarFi, we would like to control the MPTCP kernel stack from the application layer i.e. manage(open/close) sub flows according to the kind of application that uses it. For example, for a streaming application it is preferable to communicate over the Wifi channel. In the current Linux Kernel implementation of MPTCP, the path managers may not be fit for all kinds of applications. For optimum usage, advanced applications may want to know the number of sub flows available or the state of the active sub flows. When the application possesses such information it may want to create a new sub flow, terminate an existing one, change a sub flow's priority etc.

		\subsection{Implementation}
			\label{subsec:implement}
			The enhanced socket API has been implemented over the existing \textbf{\emph{getsockopt()}} and \textbf{\emph{setsockopt()}} system calls. The following figure illustrates the MPTCP socket structure \cite{api}:
			\begin{figure}[h]
			\begin{center}
				\includegraphics[scale=1.5]{pictures/mptcp_socket_structure.jpg}
				\caption[]{MPTCP socket structure}
			\end{center}
			\end{figure}

			From the application's point of view, no other socket other than the \textbf{Meta Socket} is visible. Underneath the \textbf{Meta Socket} lie several subsockets, each representing a sub flow. The structure \textbf{mptcp\_cb} points towards the head of the subflow list. The structure \textbf{mptcp\_sk} hence points indirectly towards the next subflow.
			Till now there is no way for the application to know what hides beyond the \textbf{Meta Socket}. This is where the socket options come into play. The enhanced socket API lists the following socket options for the user \cite{api}:

			\begin{table}[h]
				
				

				\begin{tabular}{l|l|l|l}
					\hline
					Name & Input & Output & Description \\
					\hline
					\hline
					MPTCP\_GET\_SUB\_IDS & - & subflow list & Get the current list of \\&&&subflows viewed by the kernel \\
					\hline
					MPTCP\_GET\_SUB\_TUPLE & id & sub tuple & Get the ip and ports used by \\&&&the subflow identified by id \\
					\hline
					MPTCP\_OPEN\_SUB\_TUPLE & tuple & - & Request a new subflow with \\&&&pair of ip and ports \\
					\hline
					MPTCP\_CLOSE\_SUB\_ID & id & - & Close the subflow identified \\&&&by id \\
					\hline
					MPTCP\_SUB\_GETSOCKOPT & id, sock opt & sock ret & Redirects the getsockopt given \\&&&in input to the subflow \\&&&identified by id and return the \\&&&value returned by the operation \\
					\hline
					MPTCP\_SUB\_SETSOCKOPT & id, sock opt & - & Redirects the setsockopt given \\&&&in input to the subflow \\&&&identified by id \\
					\hline

				\end{tabular}
				\caption{Implemented MPTCP socket options}
			\end{table}

			\raggedright{The following example shows how we may use the socket option \textbf{MPTCP\_OPEN\_SUB\_TUPLE} and \textbf{getsockopt()}to open a sub flow \cite{api}:}

			First we introduce the \textbf{mptcp\_sub\_tuple} structure which represents the subflow :
			\begin{lstlisting}
			struct mptcp_sub_tuple {
				_u8 id;			// this is an output signifying the ``id'' of the subflow
				_u8 prio;		// this field determines if the sub flow is backup or not
				_u8 addrs[0];	// pair array of size two depicting (source, destination)
			}
			\end{lstlisting}
			Now we use this structure to open a sub flow as follows :
			\begin{lstlisting}
   			unsigned int optlen;
   			struct mptcp_sub_tuple *sub_tuple;
   			struct sockaddr_in *addr;
   			optlen = 42;

   			int error;

   			optlen = sizeof(struct mptcp_sub_tuple) + 2 * sizeof(struct sockaddr_in);
   			sub_tuple = malloc(optlen);

   			sub_tuple->id = 0;
   			sub_tuple->prio = 0;

   			addr = (struct sockaddr_in*) &sub_tuple->addrs[0];

   			// source address
   			addr->sin_family = AF_INET; // address family IPv4
   			addr->sin_port = htons(12345); // source port
   			inet_pton(AF_INET, "10.0.0.1", &addr->sin_addr); // source IP

   			addr++;

   			// destination address
   			addr->sin_family = AF_INET; // address family IPv4
   			addr->sin_port = htons(1234); // destination port
   			inet_pton(AF_INET, "10.1.0.1", &addr->sin_addr); // destination IP

   			error = getsockopt(sockfd, IPPROTO_TCP, MPTCP_OPEN_SUB_TUPLE,
                    sub_tuple, &optlen); // establishment of sub flow using getsockopt()
			\end{lstlisting}

		

	
	\section{Netcat with MPTCP (netcat-mptcp) :}
		\label{sec:netcat-mptcp}
		In order to have a concrete testbed for the enhanced socket API, we have thought of a usecase involving \textbf{Netcat}. \textbf{Netcat} or \textbf{nc} is a featured networking utility which reads and writes data across network connections, using the TCP/IP protocol \cite{nc}. It will serve as our application that will establish multiple subflows.

		\subsection{Setup and structure}
			\label{subsec:setup}
			Usually with \textbf{Netcat}, there is only one flow between a client and a server. Our objective is to have multiple interfaces on the client side which will connect to the same or multiple interfaces on the server side. For simplicity we have envisaged a scenario where the client has three interfaces (viz. default, wifi and cellular) and the server has three (however for demonstration purposes we need to connect to only one of them). The way the client connects to the server is changed. In fact, with our modifications in the source code, we are able to pass three additional arguments in the netcat command :

			\begin{enumerate}
				\item \textbf{-a} : Find all the remaining interfaces on the client side and establish sub flows to the server.
				\item \textbf{-W} : Read the configuration file, extract the IP corresponding to the wifi interface and establish a sub flow using this interface to the server.
				\item \textbf{-C} : Read the configuration file, extract the IP corresponding to the cellular interface and establish a sub flow using this interface to the server.
			\end{enumerate}

			What happens is, the client usually connects to the server via the default interface. Then according to the option passed in the \textbf{Netcat} command, it either opens subflows on a single interface or on all available interfaces. This is done using the function \emph{getsockopt()} in the source code just after the TCP \emph{connect()} system call. \\
			The following diagram depicts the setup along with the addresses :
			\begin{figure}[h]
				\begin{center}
					\label{fig:topology}
					\includegraphics[scale=0.45]{pictures/topologie.jpg}
					\caption[]{Testbed topology for netcat-mptcp}
				\end{center}
			\end{figure}

			Here is an example of the \textbf{Netcat} command : \\
			On the server side, it listens on it's default interface \textbf{10.0.4.7} on port \textbf{64000} with the help of the following command : \\

			\textbf{\emph{nc -l -p 64000}} \\

			On the client side, we use our own \textbf{Netcat} executable to establish a flow / multiple flows as follows :

			
			\begin{tabbing}
			-a : ~~~~~~~~\=\textbf{\emph{./netcat-mptcp/src/netcat -a 10.0.4.7 64000}} \\
			-W : \> \textbf{\emph{./netcat-mptcp/src/netcat -W 10.0.4.7 64000}} \\
			-C : \> \textbf{\emph{./netcat-mptcp/src/netcat -C 10.0.4.7 64000}}
			\end{tabbing}


		\subsection{Configure Addresses and Routing}
			\label{subsec:addressandroute}
			For the testbed, have set up the above topology on \textbf{GNS3} using the Cisco Router \textbf{c3745} and the virtual machine enabled with the enhanced Multipath TCP API.

			\subsection{Client and Server}
			\label{subsec:clientandserver}
			The following command example assigns the address \textbf{10.0.1.6} to the interface \textbf{eth0} : \\
			\textbf{\emph{Client side :}} \\
			\begin{lstlisting}
			ip addr add 10.0.1.6/24 dev eth0
			\end{lstlisting}
			Appendix \hyperref[subsec:clientaddress]{10.1} and \hyperref[subsec:serveraddress]{10.2} illustrate the scripts that are run to assign addresses on the client side and the server side.

			With multiple addresses defined on several interfaces, we would also like to tell the kernel to use specific interfaces and gateways and not the default ones acccording to the source addresses. This has been achieved by configuring one routing table per outgoing interface, each routing table being identified by a number. The route selection process then happens in two phases : First the kernel does a lookup in the policy table (that we need to configure with \textbf{\emph{ip rules}}). The policies in our case, will be that for so and so source prefix, go to so and so routing table (the routing table indicated by a number). The corresponding routing table is examined to select the gateway based on the destination addresses \cite{routing}.

			Appendix \hyperref[subsec:clientroute]{10.3} and \hyperref[subsec:serverroute]{10.5} illustrate the scripts that are run to manually configure the routing policies on the client side and the server side.

			Appendix \hyperref[subsec:clientrouteout]{10.4} and \hyperref[subsec:serverrouteout]{10.6} illustrate the outputs for the different commands for showing the routing policies.

			\subsection{Routers}
			\label{subsec:router}
			In figure \hyperref[fig:topology]{2} the three routes need to be configured to properly deliver packets to the correct destination.
			We have connected to the routers via telnet to configure them.

			Appendix \hyperref[subsec:routerconf1]{10.7}, \hyperref[subsec:routerconf2]{10.9} and \hyperref[subsec:routerconf3]{10.11} illustrate the commands that must be given to the routers \textbf{R1, R2} and \textbf{R3} respectively.


			Appendix \hyperref[subsec:routerconfout1]{10.8}, \hyperref[subsec:routerconfout2]{10.10} and \hyperref[subsec:routerconfout3]{10.12} illustrate the outputs for the \textbf{sh ip route} command.

		\subsection{Code simplification, addition and function calls at the correct place}
			\label{subsec:codesimplify}
			The above code involving opening a sub flow may appear complex. During our participation at the \textbf{IETF'97 Hackathon} at \textbf{École Polytechnique de Louvain}, one of my fellow participants had simplified the usage of the \textbf{getsockopt()} function by deploying simpler function calls. Our aim was to find in the source code of \textbf{Netcat} where the \textbf{connect()} system call was being made. Once the the exact place found, we were to simply use the sunflow opening code in the simplified form and establish the desired subflows. We have added three different scenarios for the establishment of subflows as described in the section \hyperref[subsec:setup]{Setup and structure}.

			Besides the classes \textbf{\emph{makeaddr.c, subinfo.c, submanip.c and suboption.c}} and the header files \textbf{\emph{makeaddr.h, subinfo.h, submanip.h and suboption.h}} which are avaiable at the \textbf{src} folder of the github repository : \cite[https://github.com/lawrenceFR/netcat-mptcp]{github}, the following addition of code was also necessary for the proper functioning of \textbf{\emph{netcat-mptcp}} :
			\begin{enumerate}
				\item In \textbf{\emph{netcat-mptcp/src/Makefile.am}} line \textbf{28 - 39} : Appendix \hyperref[subsec:Makefile.am]{Makefile.am}

				\item In \textbf{\emph{netcat-mptcp/src/Makefile.in}} line \textbf{153 - 164} and \textbf{183 - 186} : Appendix \hyperref[subsec:Makefile.in]{Makefile.in}

				\item In \textbf{\emph{netcat-mptcp/src/netcat.h}} line \textbf{203 - 205} : Appendix \hyperref[subsec:netcat.h]{netcat.h}

				\item In \textbf{\emph{netcat-mptcp/src/netcat.c}} line \textbf{58 - 60}, \textbf{192}, \textbf{194}, \textbf{222}, \textbf{227}, \textbf{233 - 235}, \textbf{239 - 241}, \textbf{357 - 359} : Appendix \hyperref[subsec:netcat.c]{netcat.c}

				\item In \textbf{\emph{netcat-mptcp/src/core.h}} line \textbf{1 - 37} : Appendix \hyperref[subsec:core.h]{core.h}

				\item In \textbf{\emph{netcat-mptcp/src/core.c}} line \textbf{394 - 405} and \textbf{535 - 688} : Appendix \hyperref[subsec:core.c]{core.c}
			\end{enumerate}
			
	\clearpage
	\section{Results, Statistics and Utility}
		\label{sec:res}
		\subsection{Results}
			\label{subsec:result}
		\subsection{Statistics}
			\label{subsec:statistics}
		\subsection{Utility}
			\label{subsec:utility}

	\clearpage
	\section{Conclusion}
		\label{sec:conclusion}
	 	Conclusion
		 	
		 
	\clearpage
	\section{Further developments}
		\label{sec:furtherdevelopment}
		In the above experiments 
			
		 	
		 	
	\clearpage
	\section{Acknowledgements}
	 
	  	Acknowledgement
		 
 	\clearpage
 	\section{Bibliography}
		\bibliographystyle{unsrt}
		\bibliography{library}


	\clearpage
	\section{Appendix}
		\label{sec:appendix}
	 	Here we have the different additional information, notably the code and the scripts used in the proper functioning of our testbed.

	 	\subsection{Client side address assignment with the following script :}
	 	\label{subsec:clientaddress}
	 	\begin{lstlisting}
	 	#!/bin/sh

	 	# flush all ip addresses
	 	ip addr flush dev eth0
	 	ip addr flush dev eth1
	 	ip addr flush dev eth2

	 	# bring all the interfaces down
	 	ip link set dev eth0 down
	 	ip link set dev eth1 down
	 	ip link set dev eth2 down

	 	# bring all the interfaces up
	 	ip link set dev eth0 up
	 	ip link set dev eth1 up
	 	ip link set dev eth2 up

	 	# assign addresses to the interfaces
	 	ip addr add 10.0.1.6/24 dev eth0
	 	ip addr add 10.0.2.6/24 dev eth1
	 	ip addr add 10.0.3.6/24 dev eth2
	 	\end{lstlisting}

	 	\subsection{Server side address assignment with the following script :}
	 	\label{subsec:serveraddress}
	 	\begin{lstlisting}
	 	#!/bin/sh

	 	# flush all ip addresses
	 	ip addr flush dev eth0
	 	ip addr flush dev eth1
	 	ip addr flush dev eth2

	 	# bring all the interfaces down
	 	ip link set dev eth0 down
	 	ip link set dev eth1 down
	 	ip link set dev eth2 down

	 	# bring all the interfaces up
	 	ip link set dev eth0 up
	 	ip link set dev eth1 up
	 	ip link set dev eth2 up

	 	# assign addresses to the interfaces
	 	ip addr add 10.0.4.7/24 dev eth0
	 	ip addr add 10.0.5.7/24 dev eth1
	 	ip addr add 10.0.6.7/24 dev eth2
	 	\end{lstlisting}

	 	\subsection{Client side routing :}
	 	\label{subsec:clientroute}
	 	\begin{lstlisting}
	 	#!/bin/sh

	 	# this rule creates three different routing tables that we use based on the source addresses
	 	ip rule add from 10.0.1.6 table 1
	 	ip rule add from 10.0.2.6 table 2
	 	ip rule add from 10.0.3.6 table 3

	 	# configure the three different routing tables
	 	ip route add 10.0.1.0/24 dev eth0 scope link table 1
	 	ip route add default via 10.0.1.1 dev eth0 table 1

	 	ip route add 10.0.2.0/24 dev eth1 scope link table 2
	 	ip route add default via 10.0.2.1 dev eth1 table 2

	 	ip route add 10.0.3.0/24 dev eth2 scope link table 3
	 	ip route add default via 10.0.3.1 dev eth2 table 3

	 	# default route for the selection process of normal internet-traffic
	 	ip route add default scope global nexthop via 10.0.1.1 dev eth0
	 	\end{lstlisting}

	 	\subsection{Client routing output :}
	 	\label{subsec:clientrouteout}
	 	\begin{lstlisting}
	 	mininet@mininet-vm:~$ ip rule show
	 	0 : 	from all liiokup local
	 	32763 : from 10.0.3.6 lookup 3
	 	32764 : from 10.0.2.6 lookup 2
	 	32765 : from 10.0.1.6 lookup 1
	 	32766 : from all lookup main
	 	32767 : from all lookup default

	 	mininet@mininet-vm:~$ ip route
	 	default via 10.0.1.1 dev eth0
	 	10.0.1.0/24 dev eth0 proto kernel scope link src 10.0.1.6
	 	10.0.2.0/24 dev eth1 proto kernel scope link src 10.0.2.6
	 	10.0.3.0/24 dev eth2 proto kernel scope link src 10.0.3.6

	 	mininet@mininet-vm:~$ ip route show table 1
	 	default via 10.0.1.1 dev eth0
	 	10.0.1.0/24 dev eth0 scope link

	 	mininet@mininet-vm:~$ ip route show table 2
	 	default via 10.0.2.1 dev eth1
	 	10.0.2.0/24 dev eth0 scope link

	 	mininet@mininet-vm:~$ ip route show table 3
	 	default via 10.0.3.1 dev eth2
	 	10.0.3.0/24 dev eth0 scope link
	 	\end{lstlisting}

	 	\subsection{Server side routing :}
	 	\label{subsec:serverroute}
	 	\begin{lstlisting}
	 	#!/bin/sh

	 	# this rule creates three different routing tables that we use based on the source addresses
	 	ip rule add from 10.0.4.7 table 1
	 	ip rule add from 10.0.5.7 table 2
	 	ip rule add from 10.0.6.7 table 3

	 	# configure the three different routing tables
	 	ip route add 10.0.4.0/24 dev eth0 scope link table 1
	 	ip route add default via 10.0.4.1 dev eth0 table 1

	 	ip route add 10.0.5.0/24 dev eth1 scope link table 2
	 	ip route add default via 10.0.5.1 dev eth1 table 2

	 	ip route add 10.0.6.0/24 dev eth2 scope link table 3
	 	ip route add default via 10.0.6.1 dev eth2 table 3

	 	# default route for the selection process of normal internet-traffic
	 	ip route add default scope global nexthop via 10.0.4.1 dev eth0
	 	\end{lstlisting}

	 	\subsection{Server routing output :}
	 	\label{subsec:serverrouteout}
	 	\begin{lstlisting}
	 	mininet@mininet-vm:~$ ip rule show
	 	0 : 	from all liiokup local
	 	32763 : from 10.0.6.7 lookup 3
	 	32764 : from 10.0.5.7 lookup 2
	 	32765 : from 10.0.4.7 lookup 1
	 	32766 : from all lookup main
	 	32767 : from all lookup default

	 	mininet@mininet-vm:~$ ip route
	 	default via 10.0.4.1 dev eth0
	 	10.0.4.0/24 dev eth0 proto kernel scope link src 10.0.4.7
	 	10.0.5.0/24 dev eth1 proto kernel scope link src 10.0.5.7
	 	10.0.6.0/24 dev eth2 proto kernel scope link src 10.0.6.7

	 	mininet@mininet-vm:~$ ip route show table 1
	 	default via 10.0.4.1 dev eth0
	 	10.0.4.0/24 dev eth0 scope link

	 	mininet@mininet-vm:~$ ip route show table 2
	 	default via 10.0.5.1 dev eth1
	 	10.0.5.0/24 dev eth0 scope link

	 	mininet@mininet-vm:~$ ip route show table 3
	 	default via 10.0.6.1 dev eth2
	 	10.0.6.0/24 dev eth0 scope link
	 	\end{lstlisting}

	 	\subsection{Router R1 :}
	 	\label{subsec:routerconf1}
	 	\begin{lstlisting}
	 	enable
	 	conf t
	 	interface fastEthernet0/0
	 	ip address 10.0.1.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet0/1
	 	ip address 10.0.4.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet1/0
	 	ip address 10.0.7.1 255.255.255.0
	 	no shut
	 	exit

	 	ip route 10.0.1.0 255.255.255.0 fastEthernet0/0
	 	ip route 10.0.4.0 255.255.255.0 fastEthernet0/1
	 	ip route 0.0.0.0 0.0.0.0 fastEthernet1/0
	 	exit
	 	write
	 	sh ip route
	 	\end{lstlisting}

	 	\subsection{Router R1 routing output :}
	 	\label{subsec:routerconfout1}
	 	\begin{lstlisting}
	 	10.0.0.0/24 is subnetted, 3 subnets
	C       10.0.1.0 is directly connected, FastEthernet0/0
	C       10.0.7.0 is directly connected, FastEthernet1/0
	C       10.0.4.0 is directly connected, FastEthernet0/1
	S*   0.0.0.0/0 is directly connected, FastEthernet1/0
	 	\end{lstlisting}

	 	\subsection{Router R2 :}
	 	\label{subsec:routerconf2}
	 	\begin{lstlisting}
	 	enable
	 	conf t
	 	interface fastEthernet0/0
	 	ip address 10.0.2.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet0/1
	 	ip address 10.0.5.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet1/0
	 	ip address 10.0.7.2 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet2/0
	 	ip address 10.0.8.2 255.255.255.0
	 	no shut
	 	exit

	 	ip route 10.0.1.0 255.255.255.0 fastEthernet1/0
	 	ip route 10.0.2.0 255.255.255.0 fastEthernet0/0
	 	ip route 10.0.3.0 255.255.255.0 fastEthernet2/0
	 	ip route 10.0.4.0 255.255.255.0 fastEthernet1/0
	 	ip route 10.0.5.0 255.255.255.0 fastEthernet0/1
	 	ip route 10.0.6.0 255.255.255.0 fastEthernet2/0
	 	ip route 0.0.0.0 0.0.0.0 fastEthernet1/0
	 	exit
	 	write
	 	sh ip route
	 	\end{lstlisting}

	 	\subsection{Router R2 routing output :}
	 	\label{subsec:routerconfout2}
	 	\begin{lstlisting}
	    10.0.0.0/24 is subnetted, 8 subnets
	C       10.0.8.0 is directly connected, FastEthernet2/0
	C       10.0.2.0 is directly connected, FastEthernet0/0
	S       10.0.3.0 is directly connected, FastEthernet2/0
	S       10.0.1.0 is directly connected, FastEthernet1/0
	S       10.0.6.0 is directly connected, FastEthernet2/0
	C       10.0.7.0 is directly connected, FastEthernet1/0
	S       10.0.4.0 is directly connected, FastEthernet1/0
	C       10.0.5.0 is directly connected, FastEthernet0/1
	S*   0.0.0.0/0 is directly connected, FastEthernet1/0
	 	\end{lstlisting}

	 	\subsection{Router R3 :}
	 	\label{subsec:routerconf3}
	 	\begin{lstlisting}
	 	enable
	 	conf t
	 	interface fastEthernet0/0
	 	ip address 10.0.3.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet0/1
	 	ip address 10.0.6.1 255.255.255.0
	 	no shut
	 	exit
	 	interface fastEthernet1/0
	 	ip address 10.0.8.1 255.255.255.0
	 	no shut
	 	exit

	 	ip route 10.0.3.0 255.255.255.0 fastEthernet0/0
	 	ip route 10.0.6.0 255.255.255.0 fastEthernet0/1
	 	ip route 0.0.0.0 0.0.0.0 fastEthernet1/0
	 	exit
	 	write
	 	sh ip route
	 	\end{lstlisting}

	 	\subsection{Router R3 routing output :}
	 	\label{subsec:routerconfout3}
	 	\begin{lstlisting}
	    10.0.0.0/24 is subnetted, 3 subnets
	C       10.0.8.0 is directly connected, FastEthernet1/0
	C       10.0.3.0 is directly connected, FastEthernet0/0
	C       10.0.6.0 is directly connected, FastEthernet0/1
	S*   0.0.0.0/0 is directly connected, FastEthernet1/0
	 	\end{lstlisting}

	 	\subsection{Makefile.am :}
	 	\label{subsec:Makefile.am}
	 	\begin{lstlisting}
	 	28 	netcat_SOURCES = \
	 	29		core.c \
	 	30		flagset.c \
	 	31		misc.c \
	 	32		netcat.c \
	 	33		network.c \
	 	34		telnet.c \
	 	35		udphelper.c \
	 	36		makeaddr.c \
	 	37		subinfo.c \
	 	38		submanip.c \
	 	39		suboption.c
	 	\end{lstlisting}

	 	\subsection{Makefile.in :}
	 	\label{subsec:Makefile.in}
	 	\begin{lstlisting}
	 	153 netcat_SOURCES = \
	 	154		core.c \
	 	155		flagset.c \
	 	156		misc.c \
	 	157		netcat.c \
	 	158		network.c \
	 	159		telnet.c \
	 	160		udphelper.c \
	 	161		makeaddr.c \
	 	162		subinfo.c \
	 	163		submanip.c \
	 	164		suboption.c

	 	.
	 	.
	 	.

	 	183 am_netcat_OBJECTS = core.$(OBJEXT) flagset.$(OBJEXT) misc.$(OBJEXT) \
	 	184 	netcat.$(OBJEXT) network.$(OBJEXT) telnet.$(OBJEXT) \
	 	185 	makeaddr.$(OBJEXT) subinfo.$(OBJEXT) submanip.$(OBJEXT) \
	 	186 	suboption.$(OBJEXT)
	 	\end{lstlisting}

	 	\subsection{netcat.h :}
	 	\label{subsec:netcat.h}
	 	\begin{lstlisting}
	 	203 extern bool opt_addAllSubflows; // option to add all the remaining subflows
	 	204 extern bool opt_addWifi; // option to add the wifi subflow only
	 	205 extern bool opt_addCellular; // option to add the cellular subflow only
	 	\end{lstlisting}

	 	\subsection{netcat.c :}
	 	\label{subsec:netcat.c}
	 	\begin{lstlisting}
	 	58 bool opt_addAllSubflows = FALSE; /* option to ad all the supplementary subflows */
	 	59 bool opt_addWifi = FALSE; /* option to add the Wifi subflow */
	 	60 bool opt_addCellular = FALSE; /* option to add the Cellular subflow */

	 	.
	 	.
	 	.

	 	192 { ``all'', 		no_argument, 		NULL, `a' },

	 	...

	 	194 { ``cellular'', no_argument,		NULL, `C' },

	 	...

	 	222 { ``wifi'', 	no_argument,		NULL, `W' },

	 	...

	 	227 c = getopt_long(argc, argv, "acCde:g:G:hi:lL:no:p:P:rs:S:tTuvVxw:Wz",
		228 					long_options, &option_index);

		...

		233 case `a' :
		234 	opt_addAllSubflows = TRUE;		/* enable MPTCP all subflows */
		235 	break;

		...

		239 case `C' :
		240		opt_addCellular = TRUE;			/* enable MPTCP Cellular subflow */
		241		break;

		...

		357 case `W' :
		358		opt_addWifi = TRUE;				/*enable MPTCP Wifi subflow */
		359		break;
	 	\end{lstlisting}

	 	\subsection{core.h :}
	 	\label{subsec:core.h}
	 	\begin{lstlisting}
		21 	#include<stdio.h>
		22	#include<stdlib.h>
		23	#include<string.h>
		24
		25	#define FILENAME "config.conf"
		26	#define MAXBUF 1024
		27	#define DELIM "="
		28
		29	struct config {
		30		char wifi[MAXBUF];
		31		char cellular[MAXBUF];
		32	};
		33
		34	struct config readConfig();
		35
		36	void addAllSubflows(int);
		37	void addSubflow(int, char[]);
		\end{lstlisting}

		\subsection{core.c :}
	 	\label{subsec:core.c}
	 	\begin{lstlisting}
		394	if(opt_addWifi) {
		395		printf("\nEntering Wifi\n");
		396		struct config configstruct = readConfig();
		397		addSubflow(sock, configstruct.wifi);
	    398	} else if(opt_addCellular) {
		399		struct config configstruct = readConfig();
		400		addSubflow(sock, configstruct.cellular);
	    401	} else if(opt_addAllSubflows) {
		402		addAllSubflows(sock);
	    403	}else {
		404		printf("\nNo supplementary flow initiation asked\n");
		405	}

		.
		.
		.

		535	/* ... */
		536
		537
		538	void addAllSubflows(int sock) { 
		539	     
		540	        // structure to store the list of subflows
		541	        struct mptcp_sub_tuple_list *list;
		542	    
		543	        // d'abord trouver les interfaces disponible, puis établir les sous flux
		544	    
		545	        // get the subflow list 
		546	        if(mptcp_get_sub_list(sock, &list) != 0) {
		547	            printf("\nError getting the list of subflows !");
		548	        }
		549	        // structure to store the subflow src dst ip port
		550	        struct mptcp_sub_tuple_info struc;
		551	        // get the structure mptcp_sub_tuple_info
		552	        if(mptcp_get_sub_tuple(sock, list->subid, &struc) != 0) {
		553	            printf("\nError getting the structure mptcp_sub_tuple_info !");
		554	        }
		555	        // char array storing the client interface addresses
		556	        char client_addr[4096];
		557	        int client_port = struc.sourceP;
		558	        int server_port = struc.destP;
		559	        
		560	        // structures and variables for getting the characteristics of the other interfaces
		561	        struct ifaddrs *ifaddr, *ifa;
		562	        int family;
		563
		564		if(getifaddrs(&ifaddr) != 0) {
		565			printf("\nError getting the interface addresses !");
		566		}
		567		for(ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
		568			if(ifa->ifa_addr == NULL) {
		569				continue;
		570			}
		571			family = ifa->ifa_addr->sa_family;
		572			if(family == AF_INET) {
		573				inet_ntop(AF_INET, &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr, client_addr, INET_ADDRSTRLEN);
		574				if((strcmp(client_addr, struc.sourceH) != 0) && (strcmp(client_addr, "127.0.0.1") != 0)) {
		575					if(mptcp_add_subflow(sock, AF_INET, client_addr, ++client_port, struc.destH, server_port) != 0) {
		576						printf("\nError adding a subflow !");
		577					}
		578				}
		579			} else {
		580				//inet_ntop(AF_INET6, &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr, client_addr, INET6_ADDRSTRLEN);
		581				//if((strcmp(client_addr, struc.sourceH) != 0) && (strcmp(client_addr, "::1") != 0)) {
		582				//	if(mptcp_add_subflow(sockfd, AF_INET6, client_addr, struc.sourceP, struc.destH, struc.destP) != 0) {
		583				//		printf("\nError adding a subflow !");
		584				//	}
		585				//}
		586				printf("\nCannot treat IPv6 for the moment :/ Sorry, Yes it's kinda lame :(\n"); 
		587			}
		588		}
		589		freeifaddrs(ifaddr);
		590	   
		591	    
		592
		593	        /* display subflows */
		594	    
		595	        if(mptcp_get_sub_list(sock, &list) != 0) {
		596		    printf("\nError getting the list of subflows !");
		597	        }
		598	        while(list != NULL){
		599	            mptcp_get_sub_tuple(sock, list->subid, &struc);
		600	            printf("(%s %d) -> (%s %d)\n", struc.sourceH, struc.sourceP, struc.destH, struc.destP);
		601	            list = list->next;
		602	        }
		603	    
		604
		605
		606
		607	}
		608	/* ... */
		609
		610	void addSubflow(int sock, char ip[]) {
		611		/*
		612		printf("\nRes = %d\n", mptcp_add_subflow(sock, AF_INET, "10.0.5.7", 64101, 10.0.4.7, 64000, 1));
		613		*/
		614		
		615		printf("\nIP address read is %s\n", ip);
		616		// structure to store the list of subflows
		617	        struct mptcp_sub_tuple_list *list;
		618	 
		619	        // get the subflow list 
		620	        if(mptcp_get_sub_list(sock, &list) != 0) {
		621	            printf("\nError getting the list of subflows !");
		622	        }
		623	        // structure to store the subflow src dst ip port
		624	        struct mptcp_sub_tuple_info struc;
		625	        // get the structure mptcp_sub_tuple_info
		626	        if(mptcp_get_sub_tuple(sock, list->subid, &struc) != 0) {
		627	            printf("\nError getting the structure mptcp_sub_tuple_info !");
		628	        }
		629	        // char array storing the client interface addresses
		630	        char client_addr[4096];
		631	        int client_port = struc.sourceP;
		632	        int server_port = struc.destP;
		633	        int resultat; 
		634		if((resultat = mptcp_add_subflow(sock, AF_INET, ip, ++client_port, struc.destH, server_port)) != 0) {
		635						printf("\nError adding a subflow ! Result = %d\n", resultat);
		636		}
		637		
		638
		639		/* display subflows */
		640	         
		641	        if(mptcp_get_sub_list(sock, &list) != 0) {
		642		    printf("\nError getting the list of subflows !");
		643	        }
		644	        while(list != NULL){
		645	            mptcp_get_sub_tuple(sock, list->subid, &struc);
		646	            printf("(%s %d) -> (%s %d)\n", struc.sourceH, struc.sourceP, struc.destH, struc.destP);
		647	            list = list->next;
		648	        }
		649		
		650
		651	}
		652
		653
		654	/* ... */
		655
		656	struct config readConfig() {
		657		struct config configstruct;
		658		printf("\nReading config file\n");
		659		FILE *file = fopen("/home/mininet/netcat-mptcp/src/config.conf", "r");
		660
		661		if(file != NULL) {
		662			char line[MAXBUF];
		663			int i = 0;
		664
		665			while(fgets(line, sizeof(line), file) != NULL) {
		666				char *cfline;
		667				cfline = strstr((char *)line, DELIM);
		668				cfline = cfline + strlen(DELIM);
		669
		670				if(i == 0) {
		671					memcpy(configstruct.wifi, cfline, strlen(cfline));
		672					printf("\nWifi ip address is %s\n", configstruct.wifi);
		673				} else if(i == 1) {
		674					memcpy(configstruct.cellular, cfline, strlen(cfline));
		675					printf("\nCellular ip address is %s\n", configstruct.cellular);
		676				} else {
		677					printf("\nNo more lines\n");
		678				}
		679
		680				i++;
		681			}
		682			fclose(file);
		683		}
		684		return configstruct;
		685	}
		686
		687
		688	/* ... */
		\end{lstlisting}


	\section{Glossary}
			\begin{tabbing}
	  		RA : ~~~~~~~~\= \textit{Département d'Informatique} \\
	 	 	IETF : \> \textit{Internet Engineering Task Force} \\
	  		L2 : \> \textit{Layer 2/Link Layer of the OSI model} \\
	  		L3 : \> \textit{Layer 2/IP Layer of the OSI model} \\
	 		DHCP : \> \textit{Dynamic Host Configuration Protocol} \\
	  		DNS : \> \textit{Domain name system} \\
	  		MLD : \> \textit{Multicast Listener Discovery} \\
	  		IP : \> \textit{Internet Protocol} \\
	  		RFC : \> \textit{Request for Comment} \\
	  		ARP : \> \textit{Address Resolution Protocol} \\
	  		VLAN : \> \textit{Virtual local area network} \\
	  		AP : \> \textit{Access Point} \\
	  		RS : \> \textit{Router Solicitation} \\
	  		NS : \> \textit{Neighbour Solicitation} \\
	  		NA : \> \textit{Neighbour Advertisement} \\
	  		mDNS : \> \textit{ multicast Domain Name System} \\
	  		LLMNR : \> \textit{ Link-Local Multicast Name Resolution} \\
	  		SLAAC : \> \textit{ Stateless Address Autoconfiguration} \\
			\end{tabbing}
				
				
				

\end{document}